################################
Assumptions:
  1. sql is correct
  2. only table name has alias
  3. only one intersect/union/except

val: number(float)/string(str)/sql(dict)/col_unit
col_unit: (agg_id, col_id, isDistinct(bool))
val_unit: (unit_op, col_unit1, col_unit2)
table_unit: (table_type, tab_id/sql)
cond_unit: (not_op(bool), cmp_op, val_unit, val1, val2)
condition: [cond_unit1, 'and'/'or', cond_unit2, ...]
sql {
  'select': (isDistinct(bool), [(agg_id, val_unit), (agg_id, val_unit), ...])
  'from': {'table_units': [table_unit1, table_unit2, ...], 'conds': condition}
  'where': condition
  'groupBy': [col_unit1, col_unit2, ...]
  'orderBy': ('asc'/'desc', [val_unit1, val_unit2, ...])
  'having': condition
  'limit': None/integer
  'intersect': None/sql
  'except': None/sql
  'union': None/sql
}

CLAUSE_KEYWORDS = ('select', 'from', 'where', 'group', 'order', 'limit', 'intersect', 'union', 'except')
JOIN_KEYWORDS = ('join', 'on', 'as')

CMP_OPS = ('not', 'between', '=', '>', '<', '>=', '<=', '!=', 'in', 'like', 'is', 'exists') 
UNIT_OPS = ('none', '-', '+', "*", '/')
AGG_OPS = ('none', 'max', 'min', 'count', 'sum', 'avg')
TABLE_TYPE = ('sql', 'table_unit')
COND_OPS = ('and', 'or')
SQL_OPS = ('intersect', 'union', 'except')
ORDER_OPS = ('desc', 'asc')

################################
Dataset and table fields

data example:
    "db_id": str, # database name
    "question": str, # case sensitive
    "question_toks": list of str, # case sensitive, punctuation is separated
    "query": str, # case sensitive, all sql key toks are capital
    "query_toks": list of str, # case sensitive, all sql key toks are capital
    "query_toks_no_value": list of str, # case insensitive, all words are lowercase, dot in tab_name.col_name is separated, val is replaced with 'value'
    "sql": dict # structure parsed by official script (see the structure above)

table example:
    "db_id": str, # database name
    "column_names": list of tuple, # (table_id, column name str), first one is always (-1, '*'), lowercase, underline '_' is replaced with ' '
    "column_names_original": list of tuple, # column names are not preprocessed, underline '_' exists
    "column_types": enum, # {'others', 'text', 'time', 'number', 'boolean'}, column types for each one in column_names, '*' is always 'text'
    "foreign_keys": list of tuple, # (col_id1, col_id2), col_id is the index in column_names(col_id2 should be a primary key?)
    "primary_keys": list of int, # index in column_names
    "table_names": list of str, # lowercase table name
    "table_names_original": list of str # table names not preprocessed

#################################
Some conclusions after analyzing the entire dataset:

tables:
1. some foreign key types are not matched
2. the 2rd item of some foreign key is not a primary key

dataset: (the conclusions are based on original dataset)
1. many 'sql' field parsing result is not matched to the 'query' field, 
  but when we use the officail script to reparse, we get totally different results (the original dataset is wrong?)
2. about select clause:
  a. if distinct = True, agg != None, then val_unit can only be (0, col_id, isDistinct), e.g. Distinct COUNT(student), Distinct COUNT(Distinct score)
  b. if distinct = True, agg = None, then val_unit can only be (None, (0, col_id, False), None), e.g. Distinct age
  c. if distinct = False, agg != None, then val_unit can be 
    i. (None, (0, col_id, isDistinct), None), e.g. COUNT(student), COUNT(Distinct score)
    ii. (unit_op, (0, col_id1, False), (0, col_id2, False)), e.g. SUM(end_time - start_time)
  d. if distinct = False, agg = None, then val_unit can be 
    i. (None, (0, col_id, False), None), e.g. age
    ii. (unit_op, (0, col_id1, False), (0, col_id2, False)), e.g. end_time - start_time
  In general, there seems to be no occurrence of AGG1(AGG2(col)) or AGG1(col1) UNIT_OP AGG2(col2)
3. about from clause:
  a. from clause conditions can only be in the form t1.col1 = t2.col2, and connected by 'and'
  b. from conditions do not need to be foreign key constraints (but mostly), even omit the foreign key joins
  c. num of from conditions can be larger than num_of_table_units - 1, that is two tables are joined using multiple conditions
  c. from clause can use the same table multiple times with different aliases
  d. if 'sql' occurs in table_units, there must be only one and the from condition is empty
  e. Attention: some tables that are required is not used in from table_units, ERROR in dataset?
3. about where clause conditions:
  a. 'and'/'or' can occur alternatively
  b. col_unit can not have agg operator nor distinct flag
  c. in dataset, unit_op of val_unit can be none, -
  d. val can be all 4 types
4. about groupBy clause col_units:
  a. can have multiple columns
  b. col_unit can only be (0, col_id, False)
5. about having clause:
  a. if having != [], groupBy must exists
  b. can have multiple conditions, 'and/or' are both allowed
  c. can have nested sql as values
  d. in dataset, cmp_op can be between, =, >, <, >=, <=
  e. in dataset, unit_op of val_unit can only be none, agg of col_unit can be none  
  f. in dataset, val can not be col_unit, col_unit can have distinct flag
6. about orderBy clause and limit
  a. if limit != None, orderBy must exists
  b. in dataset, unit_op of val_unit can be none, -, +
  c. in dataset, col_unit in val_unit can have agg or distinct flag, but groupBy must exist if agg occurs

Some basic observations:
1. in conditions, val2 is not None iff cmp_op = between, in dataset, val2 can only be string or float
2. in cmp_op, not is only used to modify 'in' and 'like', 'is' and 'exists' never occur
3. as for operator 'in/not_in', the val must be a nested sql
4. for val_unit, if unit_op is not none (+/-/*//), then col_unit1 and col_unit2 must be (0, col_id, False)

###########################################

After updating dataset, we still find table inconsitency:
1. database formula_1: 'table_names' and 'table_names_original' are different
  The sql field dict is built upon 'table_names_original', which is different from 'table_names' in table indexes.
  To be specific, table 'circuits' in table_names_original is moved ahead
2. in process_sql.py script function `get_tables_with_alias`, if a sql has nested sql 
  where the same table alias is assigned to different tables in different sqls, the previous one can be overwitten.

##############################################

# semQL grammar rules proposed by IRNet
Root1 = intersect Root Root | union Root Root | except Root Root | Root
Root = Sel Sup Filter | Sel Filter Order | Sel Sup | Sel Filter | Sel Order | Sel
Sel = N
N = A | A A | A A A | A A A A | A A A A A
A = none C | max C | min C | count C | sum C | avg C
C = T
T = min
Filter = and Filter Filter | or Filter Filter
    | = A | != A | < A | > A | <= A | >= A | between A | like A | not_like A 
    | = A Root | < A Root | > A Root | != A Root | between A Root | >= A Root | <= A Root | in A Root | not_in A Root
Sup = des A | asc A
Order = des A | asc A

# reasons that IRNet fails to parse:
1. some join conditions are not foreign key constraints
2. some foreign key constraints are not used though exist
3. some tables only appear in from but not required in other clauses
4. from clause can have nested sqls
5. from clause can use the same table multiple times
6. groupBy clause can not be neglected, since some samples which contain groupBy clause do not have having conditions
7. having clause may have none agg conditions (contradictory to their assumptions)
8. val_unit is processed by ignoring unit_op, no -/+/*//
9. dataset intrinsic problem

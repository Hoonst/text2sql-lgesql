# Assumptions:
# 1. sql is correct
# 2. only table name has alias
# 3. only one intersect/union/except

# val: value(float/string)/sql(dict)/col_unit(tuple)
# col_unit: (agg_id, col_id, isDistinct(bool))
# val_unit: (unit_op, col_unit1, col_unit2)
# table_unit: (table_type, tab_id/sql)
# cond_unit: (not_op(bool), cmp_op, val_unit, val1, val2)
# condition: [cond_unit1, 'and'/'or', cond_unit2, ...]
# sql {
#   'select': (isDistinct(bool), [(agg_id, val_unit), (agg_id, val_unit), ...])
#   'from': {'table_units': [table_unit1, table_unit2, ...], 'conds': condition}
#   'where': condition
#   'groupBy': [col_unit1, col_unit2, ...]
#   'orderBy': ('asc'/'desc', [val_unit1, val_unit2, ...])
#   'having': condition
#   'limit': None/integer
#   'intersect': None/sql
#   'except': None/sql
#   'union': None/sql
# }

# CLAUSE_KEYWORDS = ('select', 'from', 'where', 'group', 'order', 'limit', 'intersect', 'union', 'except')
# JOIN_KEYWORDS = ('join', 'on', 'as')
# CMP_OPS = ('not', 'between', '=', '>', '<', '>=', '<=', '!=', 'in', 'like', 'is', 'exists') 
# UNIT_OPS = ('none', '-', '+', "*", '/')
# AGG_OPS = ('none', 'max', 'min', 'count', 'sum', 'avg')
# TABLE_TYPE = ('sql', 'table_unit')
# COND_OPS = ('and', 'or')
# SQL_OPS = ('intersect', 'union', 'except')
# ORDER_OPS = ('desc', 'asc')

##########################################################################

# 1. we try to eliminate cardinality ? by expanding the number of constructors
# 2. since value evaluation is not common practice, we remove the GenTokenAction for int, string and float, and only deal with column and sql
# 3. since agg(col1 op col2) is not common, agg(col1) op agg(col2) never appears, we simplify definition of val_unit 
# 4. we parse from clause first to pre-determine all table units we will use (maybe run-time constraints)
# 5. distinct flag is not predicted since we do not evaluate on it
# 6. from conds are deduced by database/graph inference instead of directly generation

col_id, tab_id

sql = Intersect(sql_unit sql_unit1, sql_unit sql_unit2)
        | Union(sql_unit sql_unit1, sql_unit sql_unit2)
        | Except(sql_unit sql_unit1, sql_unit sql_unit2)
        | Single(sql_unit sql_unit1)

sql_unit = Complete(from from_clause, val_unit* select_clause, cond where_clause, group_by group_by_clause, order_by order_by_clause)
        | NoWhere(from from_clause, val_unit* select_clause, group_by group_by_clause, order_by order_by_clause)
        | NoGroupBy(from from_clause, val_unit* select_clause, cond where_clause, order_by order_by_clause)
        | NoOrderBy(from from_clause, val_unit* select_clause, cond where_clause, group_by group_by_clause)
        | OnlyWhere(from from_clause, val_unit* select_clause, cond where_clause)
        | OnlyGroupBy(from from_clause, val_unit* select_clause, group_by group_by_clause)
        | OnlyOrderBy(from from_clause, val_unit* select_clause, order_by order_by_clause)
        | Simple(from from_clause, val_unit* select_clause)

from = FromTable(tab_id* tab_id_list)
        | FromSQL(sql sql)

group_by = Having(col_id* col_id_list, cond having_clause)
        | NoHaving(col_id* col_id_list)

order_by = Asc(val_unit* val_unit_list)
        | Desc(val_unit* val_unit_list)
        | AscLimit(val_unit* val_unit_list)
        | DescLimit(val_unit* val_unit_list)

cond = And(cond left, cond right)
        | Or(cond left, cond right)
        | Between(val_unit val_unit, val val1, val val2)
        | Eq(val_unit val_unit, val val1)
        | Gt(val_unit val_unit, val val1)
        | Lt(val_unit val_unit, val val1)
        | Ge(val_unit val_unit, val val1)
        | Le(val_unit val_unit, val val1)
        | Neq(val_unit val_unit, val val1)
        | In(val_unit val_unit, sql sql)
        | NotIn(val_unit val_unit, sql sql)
        | Like(val_unit val_unit, val val)
        | NotLike(val_unit val_unit, val val)

agg_op = None | Max | Min | Count | Sum | Avg

val_unit = Unary(agg_op agg, col_id col_id)
        | Minus(col_id col_id1, col_id col_id2)
        | Plus(col_id col_id1, col_id col_id2)
        | Times(col_id col_id1, col_id col_id2)
        | Divide(col_id col_id1, col_id col_id2)

val = ColumnVal(col_id col_id) | SQLVal(sql sql) | Value